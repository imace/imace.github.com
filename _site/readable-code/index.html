<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         Imace
    -->
    <meta charset="utf-8" />
    <title>编写可读代码的艺术 | imace</title>
    <meta name="author" content="Imace" />
    <meta name="description" content="Imace's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">Imace</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/beiyuu/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/beiyuu/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
            <a href="http://instagram.com/beiyuu/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/readable-code" title="编写可读代码的艺术">编写可读代码的艺术</a></h1>
        <p class="entry-date">2013-03-21</p>
        <p>这是《The Art of Readable Code》的读书笔记，再加一点自己的认识。强烈推荐此书：</p>

<ul>
<li>英文版：<a href="http://book.douban.com/subject/5442971/" title="The Art Of Readable Code">《The Art of Readable Code》</a></li>
<li>中文版：<a href="http://book.douban.com/subject/10797189/" title="编写可读代码的艺术">编写可读代码的艺术</a></li>
</ul>


<h2>代码为什么要易于理解</h2>

<blockquote><p>"Code should be written to minimize the time it would take for someone else to understand it."</p></blockquote>

<p>日常工作的事实是：</p>

<ul>
<li>写代码前的思考和看代码的时间远大于真正写的时间</li>
<li>读代码是很平常的事情，不论是别人的，还是自己的，半年前写的可认为是别人的代码</li>
<li>代码可读性高，很快就可以理解程序的逻辑，进入工作状态</li>
<li>行数少的代码不一定就容易理解</li>
<li>代码的可读性与程序的效率、架构、易于测试一点也不冲突</li>
</ul>


<p>整本书都围绕“如何让代码的可读性更高”这个目标来写。这也是好代码的重要标准之一。</p>

<h2>如何命名</h2>

<h3>变量名中应包含更多信息</h3>

<h4>使用含义明确的词，比如用<code>download</code>而不是<code>get</code>，参考以下替换方案：</h4>

<pre><code> send -&gt; deliver, dispatch, announce, distribute, route
 find -&gt; search, extract, locate, recover
start -&gt; lanuch, create, begin, open
 make -&gt; create,set up, build, generate, compose, add, new
</code></pre>

<h4>避免通用的词</h4>

<p>像<code>tmp</code>和<code>retval</code>这样词，除了说明是临时变量和返回值之外，没有任何意义。但是给他加一些有意义的词，就会很明确：</p>

<pre><code>tmp_file = tempfile.NamedTemporaryFile() 
...
SaveData(tmp_file, ...)
</code></pre>

<p>不使用retval而使用变量真正代表的意义：</p>

<pre><code>sum_squares += v[i]; // Where's the "square" that we're summing? Bug!
</code></pre>

<p>嵌套的for循环中,<code>i</code>、<code>j</code>也有同样让人困惑的时候：</p>

<pre><code>for (int i = 0; i &lt; clubs.size(); i++)
    for (int j = 0; j &lt; clubs[i].members.size(); j++)
        for (int k = 0; k &lt; users.size(); k++) if (clubs[i].members[k] == users[j])
            cout &lt;&lt; "user[" &lt;&lt; j &lt;&lt; "] is in club[" &lt;&lt; i &lt;&lt; "]" &lt;&lt; endl;
</code></pre>

<p>换一种写法就会清晰很多：</p>

<pre><code> if (clubs[ci].members[mi] == users[ui])  # OK. First letters match.
</code></pre>

<p>所以，当使用一些通用的词，要有充分的理由才可以。</p>

<h4>使用具体的名字</h4>

<p><code>CanListenOnPort</code>就比<code>ServerCanStart</code>好，can start比较含糊，而listen on port确切的说明了这个方法将要做什么。</p>

<p><code>--run_locally</code>就不如<code>--extra_logging</code>来的明确。</p>

<h4>增加重要的细节，比如变量的单位<code>_ms</code>，对原始字符串加<code>_raw</code></h4>

<p>如果一个变量很重要，那么在名字上多加一些额外的字就会更加易读，比如将<code>string id; // Example: "af84ef845cd8"</code>换成<code>string hex_id;</code>。</p>

<pre><code>             Start(int delay)  --&gt;  delay → delay_secs
        CreateCache(int size)  --&gt;  size → size_mb
ThrottleDownload(float limit)  --&gt;  limit → max_kbps
          Rotate(float angle)  --&gt;  angle → degrees_cw
</code></pre>

<p>更多例子：</p>

<pre><code>password  -&gt;  plaintext_password
 comment  -&gt;  unescaped_comment
    html  -&gt;  html_utf8
    data  -&gt;  data_urlenc
</code></pre>

<h4>对于作用域大的变量使用较长的名字</h4>

<p>在比较小的作用域内，可以使用较短的变量名，在较大的作用域内使用的变量，最好用长一点的名字，编辑器的自动补全都可以很好的减少键盘输入。对于一些缩写前缀，尽量选择众所周知的(如str)，一个判断标准是，当新成员加入时，是否可以无需他人帮助而明白前缀代表什么。</p>

<h4>合理使用<code>_</code>、<code>-</code>等符号，比如对私有变量加<code>_</code>前缀。</h4>

<pre><code>var x = new DatePicker(); // DatePicker() 是类的"构造"函数，大写开始
var y = pageHeight(); // pageHeight() 是一个普通函数

var $all_images = $("img"); // $all_images 是jQuery对象
var height = 250; // height不是

//id和class的写法分开
&lt;div id="middle_column" class="main-content"&gt; ...
</code></pre>

<h3>命名不能有歧义</h3>

<p>命名的时候可以先想一下，我要用的这个词是否有别的含义。举个例子：</p>

<pre><code>results = Database.all_objects.filter("year &lt;= 2011")
</code></pre>

<p>现在的结果到底是包含2011年之前的呢还是不包含呢？</p>

<h4>使用<code>min</code>、<code>max</code>代替<code>limit</code></h4>

<pre><code>CART_TOO_BIG_LIMIT = 10
    if shopping_cart.num_items() &gt;= CART_TOO_BIG_LIMIT:
        Error("Too many items in cart.")

MAX_ITEMS_IN_CART = 10
    if shopping_cart.num_items() &gt; MAX_ITEMS_IN_CART:
     Error("Too many items in cart.")
</code></pre>

<p>对比上例中<code>CART_TOO_BIG_LIMIT</code>和<code>MAX_ITEMS_IN_CART</code>，想想哪个更好呢？</p>

<h4>使用<code>first</code>和<code>last</code>来表示闭区间</h4>

<pre><code>print integer_range(start=2, stop=4)
# Does this print [2,3] or [2,3,4] (or something else)?

set.PrintKeys(first="Bart", last="Maggie")
</code></pre>

<p><code>first</code>和<code>last</code>含义明确，适宜表示闭区间。</p>

<h4>使用<code>beigin</code>和<code>end</code>表示前闭后开([2,9))区间</h4>

<pre><code>PrintEventsInRange("OCT 16 12:00am", "OCT 17 12:00am")

PrintEventsInRange("OCT 16 12:00am", "OCT 16 11:59:59.9999pm")
</code></pre>

<p>上面一种写法就比下面的舒服多了。</p>

<h4>Boolean型变量命名</h4>

<pre><code>bool read_password = true;
</code></pre>

<p>这是一个很危险的命名，到底是需要读取密码呢，还是密码已经被读取呢，不知道，所以这个变量可以使用<code>user_is_authenticated</code>代替。通常，给Boolean型变量添加<code>is</code>、<code>has</code>、<code>can</code>、<code>should</code>可以让含义更清晰，比如：</p>

<pre><code>             SpaceLeft()  --&gt;  hasSpaceLeft()
bool disable_ssl = false  --&gt;  bool use_ssl = true
</code></pre>

<h4>符合预期</h4>

<pre><code>public class StatisticsCollector {
    public void addSample(double x) { ... }
    public double getMean() {
        // Iterate through all samples and return total / num_samples
    }
    ...
}
</code></pre>

<p>在这个例子中，<code>getMean</code>方法遍历了所有的样本，返回总额，所以并不是普通意义上轻量的<code>get</code>方法，所以应该取名<code>computeMean</code>比较合适。</p>

<h2>漂亮的格式</h2>

<p>写出来漂亮的格式，充满美感，读起来自然也会舒服很多，对比下面两个例子：</p>

<pre><code>class StatsKeeper {
   public:
   // A class for keeping track of a series of doubles
      void Add(double d);  // and methods for quick statistics about them
     private:   int count;        /* how many so    far
   */ public:
           double Average();
   private:   double minimum;
   list&lt;double&gt;
     past_items
         ;double maximum;
};
</code></pre>

<p>什么是充满美感的呢：</p>

<pre><code>// A class for keeping track of a series of doubles
// and methods for quick statistics about them.
class StatsKeeper {
  public:
    void Add(double d);
    double Average();
  private:
    list&lt;double&gt; past_items;
    int count;  // how many so far
    double minimum;
    double maximum;
};
</code></pre>

<h3>考虑断行的连续性和简洁</h3>

<p>这段代码需要断行，来满足不超过一行80个字符的要求，参数也需要注释说明：</p>

<pre><code>public class PerformanceTester {
    public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(
        500, /* Kbps */
        80, /* millisecs latency */
        200, /* jitter */
        1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator(
        45000, /* Kbps */
        10, /* millisecs latency */
        0, /* jitter */
        0 /* packet loss % */);

    public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(
        100, /* Kbps */
        400, /* millisecs latency */
        250, /* jitter */
        5 /* packet loss % */);
}
</code></pre>

<p>考虑到代码的连贯性，先优化成这样：</p>

<pre><code>public class PerformanceTester {
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(
            500, /* Kbps */
            80, /* millisecs latency */ 200, /* jitter */
            1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(
            45000, /* Kbps */
            10,    /* millisecs latency */
            0,     /* jitter */
            0      /* packet loss % */);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(
            100,   /* Kbps */
            400,   /* millisecs latency */
            250,   /* jitter */
            5      /* packet loss % */);
}
</code></pre>

<p>连贯性好一点，但还是太罗嗦，额外占用很多空间：</p>

<pre><code>public class PerformanceTester {
    // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)
    //                            [Kbps]   [ms]    [ms]    [percent]
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(500,    80,     200,     1);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(45000,  10,     0,       0);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(100,    400,    250,     5);
}
</code></pre>

<h3>用函数封装</h3>

<pre><code>// Turn a partial_name like "Doug Adams" into "Mr. Douglas Adams".
// If not possible, 'error' is filled with an explanation.
string ExpandFullName(DatabaseConnection dc, string partial_name, string* error);

DatabaseConnection database_connection;
string error;
assert(ExpandFullName(database_connection, "Doug Adams", &amp;error)
        == "Mr. Douglas Adams");
assert(error == "");
assert(ExpandFullName(database_connection, " Jake Brown ", &amp;error)
        == "Mr. Jacob Brown III");
assert(error == "");
assert(ExpandFullName(database_connection, "No Such Guy", &amp;error) == "");
assert(error == "no match found");
assert(ExpandFullName(database_connection, "John", &amp;error) == "");
assert(error == "more than one result");
</code></pre>

<p>上面这段代码看起来很脏乱，很多重复性的东西，可以用函数封装：</p>

<pre><code>CheckFullName("Doug Adams", "Mr. Douglas Adams", "");
CheckFullName(" Jake Brown ", "Mr. Jake Brown III", "");
CheckFullName("No Such Guy", "", "no match found");
CheckFullName("John", "", "more than one result");

void CheckFullName(string partial_name,
                   string expected_full_name,
                   string expected_error) {
    // database_connection is now a class member
    string error;
    string full_name = ExpandFullName(database_connection, partial_name, &amp;error);
    assert(error == expected_error);
    assert(full_name == expected_full_name);
}
</code></pre>

<h3>列对齐</h3>

<p>列对齐可以让代码段看起来更舒适：</p>

<pre><code>CheckFullName("Doug Adams"   , "Mr. Douglas Adams" , "");
CheckFullName(" Jake  Brown ", "Mr. Jake Brown III", "");
CheckFullName("No Such Guy"  , ""                  , "no match found");
CheckFullName("John"         , ""                  , "more than one result");

commands[] = {
    ...
    { "timeout"      , NULL              , cmd_spec_timeout},
    { "timestamping" , &amp;opt.timestamping , cmd_boolean},
    { "tries"        , &amp;opt.ntry         , cmd_number_inf},
    { "useproxy"     , &amp;opt.use_proxy    , cmd_boolean},
    { "useragent"    , NULL              , cmd_spec_useragent},
    ...
};
</code></pre>

<h3>代码用块区分</h3>

<pre><code>class FrontendServer {
    public:
        FrontendServer();
        void ViewProfile(HttpRequest* request);
        void OpenDatabase(string location, string user);
        void SaveProfile(HttpRequest* request);
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void FindFriends(HttpRequest* request);
        void ReplyNotFound(HttpRequest* request, string error);
        void CloseDatabase(string location);
        ~FrontendServer();
};
</code></pre>

<p>上面这一段虽然能看，不过还有优化空间：</p>

<pre><code>class FrontendServer {
    public:
        FrontendServer();
        ~FrontendServer();
        // Handlers
        void ViewProfile(HttpRequest* request);
        void SaveProfile(HttpRequest* request);
        void FindFriends(HttpRequest* request);

        // Request/Reply Utilities
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void ReplyNotFound(HttpRequest* request, string error);

        // Database Helpers
        void OpenDatabase(string location, string user);
        void CloseDatabase(string location);
};
</code></pre>

<p>再来看一段代码：</p>

<pre><code># Import the user's email contacts, and match them to users in our system.
# Then display a list of those users that he/she isn't already friends with.
def suggest_new_friends(user, email_password):
    friends = user.friends()
    friend_emails = set(f.email for f in friends)
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)
    display['user'] = user
    display['friends'] = friends
    display['suggested_friends'] = suggested_friends
    return render("suggested_friends.html", display)
</code></pre>

<p>全都混在一起，视觉压力相当大，按功能化块：</p>

<pre><code>def suggest_new_friends(user, email_password):
    # Get the user's friends' email addresses.
    friends = user.friends()
    friend_emails = set(f.email for f in friends)

    # Import all email addresses from this user's email account.
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)

    # Find matching users that they aren't already friends with.
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)

    # Display these lists on the page. display['user'] = user
    display['friends'] = friends
    display['suggested_friends'] = suggested_friends

    return render("suggested_friends.html", display)
</code></pre>

<p>让代码看起来更舒服，需要在写的过程中多注意，培养一些好的习惯，尤其当团队合作的时候，代码风格比如大括号的位置并没有对错，但是不遵循团队规范那就是错的。</p>

<h2>如何写注释</h2>

<p>当你写代码的时候，你会思考很多，但是最终呈现给读者的就只剩代码本身了，额外的信息丢失了，所以注释的目的就是让读者了解更多的信息。</p>

<h3>应该注释什么</h3>

<h4>不应该注释什么</h4>

<p>这样的注释毫无价值：</p>

<pre><code>// The class definition for Account
class Account {
    public:
        // Constructor
        Account();
        // Set the profit member to a new value
        void SetProfit(double profit);
        // Return the profit from this Account
        double GetProfit();
};
</code></pre>

<h4>不要像下面这样为了注释而注释：</h4>

<pre><code>// Find a Node with the given 'name' or return NULL.
// If depth &lt;= 0, only 'subtree' is inspected.
// If depth == N, only 'subtree' and N levels below are inspected.
Node* FindNodeInSubtree(Node* subtree, string name, int depth);
</code></pre>

<h4>不要给烂取名注释</h4>

<pre><code>// Enforce limits on the Reply as stated in the Request,
// such as the number of items returned, or total byte size, etc. 
void CleanReply(Request request, Reply reply);
</code></pre>

<p>注释的大部分都在解释clean是什么意思，那不如换个正确的名字：</p>

<pre><code>// Make sure 'reply' meets the count/byte/etc. limits from the 'request' 
void EnforceLimitsFromRequest(Request request, Reply reply);
</code></pre>

<h4>记录你的想法</h4>

<p>我们讨论了不该注释什么，那么应该注释什么呢？注释应该记录你思考代码怎么写的结果，比如像下面这些：</p>

<pre><code>// Surprisingly, a binary tree was 40% faster than a hash table for this data.
// The cost of computing a hash was more than the left/right comparisons.

// This heuristic might miss a few words. That's OK; solving this 100% is hard.

// This class is getting messy. Maybe we should create a 'ResourceNode' subclass to
// help organize things.
</code></pre>

<p>也可以用来记录流程和常量：</p>

<pre><code>// TODO: use a faster algorithm
// TODO(dustin): handle other image formats besides JPEG

NUM_THREADS = 8 # as long as it's &gt;= 2 * num_processors, that's good enough.

// Impose a reasonable limit - no human can read that much anyway.
const int MAX_RSS_SUBSCRIPTIONS = 1000;
</code></pre>

<p>可用的词有：</p>

<pre><code>TODO  : Stuff I haven't gotten around to yet
FIXME : Known-broken code here
HACK  : Adimittedly inelegant solution to a problem
XXX   : Danger! Major problem here
</code></pre>

<h4>站在读者的角度去思考</h4>

<p>当别人读你的代码时，让他们产生疑问的部分，就是你应该注释的地方。</p>

<pre><code>struct Recorder {
    vector&lt;float&gt; data;
    ...
    void Clear() {
        vector&lt;float&gt;().swap(data); // Huh? Why not just data.clear()? 
    }
};
</code></pre>

<p>很多C++的程序员啊看到这里，可能会想为什么不用<code>data.clear()</code>来代替<code>vector.swap</code>，所以那个地方应该加上注释：</p>

<pre><code>// Force vector to relinquish its memory (look up "STL swap trick")
vector&lt;float&gt;().swap(data);
</code></pre>

<h4>说明可能陷阱</h4>

<p>你在写代码的过程中，可能用到一些hack，或者有其他需要读代码的人知道的陷阱，这时候就应该注释：</p>

<pre><code>void SendEmail(string to, string subject, string body);
</code></pre>

<p>而实际上这个发送邮件的函数是调用别的服务，有超时设置，所以需要注释：</p>

<pre><code>// Calls an external service to deliver email.  (Times out after 1 minute.)
void SendEmail(string to, string subject, string body);
</code></pre>

<h4>全景的注释</h4>

<p>有时候为了更清楚说明，需要给整个文件加注释，让读者有个总体的概念：</p>

<pre><code>// This file contains helper functions that provide a more convenient interface to our
// file system. It handles file permissions and other nitty-gritty details.
</code></pre>

<h4>总结性的注释</h4>

<p>即使是在函数内部，也可以有类似文件注释那样的说明注释：</p>

<pre><code># Find all the items that customers purchased for themselves.
for customer_id in all_customers:
    for sale in all_sales[customer_id].sales:
        if sale.recipient == customer_id:
            ...
</code></pre>

<p>或者按照函数的步进，写一些注释：</p>

<pre><code>def GenerateUserReport():
    # Acquire a lock for this user
    ...
    # Read user's info from the database
    ...
    # Write info to a file
    ...
    # Release the lock for this user
</code></pre>

<p>很多人不愿意写注释，确实，要写好注释也不是一件简单的事情，也可以在文件专门的地方，留个写注释的区域，可以写下你任何想说的东西。</p>

<h3>注释应简明准确</h3>

<p>前一个小节讨论了注释应该写什么，这一节来讨论应该怎么写，因为注释很重要，所以要写的精确，注释也占据屏幕空间，所以要简洁。</p>

<h4>精简注释</h4>

<pre><code>// The int is the CategoryType.
// The first float in the inner pair is the 'score',
// the second is the 'weight'.
typedef hash_map&lt;int, pair&lt;float, float&gt; &gt; ScoreMap;
</code></pre>

<p>这样写太罗嗦了，尽量精简压缩成这样：</p>

<pre><code>// CategoryType -&gt; (score, weight)
typedef hash_map&lt;int, pair&lt;float, float&gt; &gt; ScoreMap;
</code></pre>

<h4>避免有歧义的代词</h4>

<pre><code>// Insert the data into the cache, but check if it's too big first.
</code></pre>

<p>这里的<code>it's</code>有歧义，不知道所指的是<code>data</code>还是<code>cache</code>，改成如下：</p>

<pre><code>// Insert the data into the cache, but check if the data is too big first.
</code></pre>

<p>还有更好的解决办法，这里的<code>it</code>就有明确所指：</p>

<pre><code>// If the data is small enough, insert it into the cache.
</code></pre>

<h4>语句要精简准确</h4>

<pre><code># Depending on whether we've already crawled this URL before, give it a different priority.
</code></pre>

<p>这句话理解起来太费劲，改成如下就好理解很多：</p>

<pre><code># Give higher priority to URLs we've never crawled before.
</code></pre>

<h4>精确描述函数的目的</h4>

<pre><code>// Return the number of lines in this file.
int CountLines(string filename) { ... }
</code></pre>

<p>这样的一个函数，用起来可能会一头雾水，因为他可以有很多歧义：</p>

<ul>
<li>"" 一个空文件，是0行还是1行？</li>
<li>"hello" 只有一行，那么返回值是0还是1？</li>
<li>"hello\n" 这种情况返回1还是2？</li>
<li>"hello\n world" 返回1还是2？</li>
<li>"hello\n\r cruel\n world\r" 返回2、3、4哪一个呢？</li>
</ul>


<p>所以注释应该这样写：</p>

<pre><code>// Count how many newline bytes ('\n') are in the file.
int CountLines(string filename) { ... }
</code></pre>

<h4>用实例说明边界情况</h4>

<pre><code>// Rearrange 'v' so that elements &lt; pivot come before those &gt;= pivot;
// Then return the largest 'i' for which v[i] &lt; pivot (or -1 if none are &lt; pivot)
int Partition(vector&lt;int&gt;* v, int pivot);
</code></pre>

<p>这个描述很精确，但是如果再加入一个例子，就更好了：</p>

<pre><code>// ...
// Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1
int Partition(vector&lt;int&gt;* v, int pivot);
</code></pre>

<h4>说明你的代码的真正目的</h4>

<pre><code>void DisplayProducts(list&lt;Product&gt; products) {
    products.sort(CompareProductByPrice);
    // Iterate through the list in reverse order
    for (list&lt;Product&gt;::reverse_iterator it = products.rbegin(); it != products.rend();
            ++it)
        DisplayPrice(it-&gt;price);
    ... 
}
</code></pre>

<p>这里的注释说明了倒序排列，单还不够准确，应该改成这样：</p>

<pre><code>// Display each price, from highest to lowest
for (list&lt;Product&gt;::reverse_iterator it = products.rbegin(); ... )
</code></pre>

<h4>函数调用时的注释</h4>

<p>看见这样的一个函数调用，肯定会一头雾水：</p>

<pre><code>Connect(10, false);
</code></pre>

<p>如果加上这样的注释，读起来就清楚多了：</p>

<pre><code>def Connect(timeout, use_encryption):  ...

# Call the function using named parameters
Connect(timeout = 10, use_encryption = False)
</code></pre>

<h4>使用信息含量丰富的词</h4>

<pre><code>// This class contains a number of members that store the same information as in the
// database, but are stored here for speed. When this class is read from later, those
// members are checked first to see if they exist, and if so are returned; otherwise the
// database is read from and that data stored in those fields for next time.
</code></pre>

<p>上面这一大段注释，解释的很清楚，如果换一个词来代替，也不会有什么疑惑：</p>

<pre><code>// This class acts as a caching layer to the database.
</code></pre>

<h2>简化循环和逻辑</h2>

<h3>流程控制要简单</h3>

<p>让条件语句、循环以及其他控制流程的代码尽可能自然，让读者在阅读过程中不需要停顿思考或者在回头查找，是这一节的目的。</p>

<h4>条件语句中参数的位置</h4>

<p>对比下面两种条件的写法：</p>

<pre><code>if (length &gt;= 10)
while (bytes_received &lt; bytes_expected)

if (10 &lt;= length)
while (bytes_expected &gt; bytes_received)
</code></pre>

<p>到底是应该按照大于小于的顺序来呢，还是有其他的准则？是的，应该按照参数的意义来</p>

<ul>
<li>运算符左边：通常是需要被检查的变量，也就是会经常变化的</li>
<li>运算符右边：通常是被比对的样本，一定程度上的常量</li>
</ul>


<p>这就解释了为什么<code>bytes_received &lt; bytes_expected</code>比反过来更好理解。</p>

<h4>if/else的顺序</h4>

<p>通常，<code>if/else</code>的顺序你可以自由选择，下面这两种都可以：</p>

<pre><code>if (a == b) {
    // Case One ...
} else {
    // Case Two ...
}

if (a != b) {
    // Case Two ...
} else {
    // Case One ...
}
</code></pre>

<p>或许对此你也没有仔细斟酌过，但在有些时候，一种顺序确实好过另一种：</p>

<ul>
<li>正向的逻辑在前，比如<code>if(debug)</code>就比<code>if(!debug)</code>好</li>
<li>简单逻辑的在前，这样<code>if</code>和<code>else</code>就可以在一个屏幕显示</li>
<li>有趣、清晰的逻辑在前</li>
</ul>


<p>举个例子来看：</p>

<pre><code>if (!url.HasQueryParameter("expand_all")) {
    response.Render(items);
    ...
} else {
    for (int i = 0; i &lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
}
</code></pre>

<p>看到<code>if</code>你首先想到的是<code>expand_all</code>，就好像告诉你“不要想大象”，你会忍不住去想它，所以产生了一点点迷惑，最好写成：</p>

<pre><code>if (url.HasQueryParameter("expand_all")) {
    for (int i = 0; i &lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
} else {
    response.Render(items);
    ... 
}
</code></pre>

<h4>三目运算符(?:)</h4>

<pre><code>time_str += (hour &gt;= 12) ? "pm" : "am";

Avoiding the ternary operator, you might write:
    if (hour &gt;= 12) {
        time_str += "pm";
    } else {
        time_str += "am";
}
</code></pre>

<p>使用三目运算符可以减少代码行数，上例就是一个很好的例证，但是我们的真正目的是减少读代码的时间，所以下面的情况并不适合用三目运算符：</p>

<pre><code>return exponent &gt;= 0 ? mantissa * (1 &lt;&lt; exponent) : mantissa / (1 &lt;&lt; -exponent);

if (exponent &gt;= 0) {
    return mantissa * (1 &lt;&lt; exponent);
} else {
    return mantissa / (1 &lt;&lt; -exponent);
}
</code></pre>

<p>所以只在简单表达式的地方用。</p>

<h4>避免使用do/while表达式</h4>

<pre><code>do {
    continue;
} while (false);
</code></pre>

<p>这段代码会执行几遍呢，需要时间思考一下，<code>do/while</code>完全可以用别的方法代替，所以应避免使用。</p>

<h4>尽早return</h4>

<pre><code>public boolean Contains(String str, String substr) {
    if (str == null || substr == null) return false;
    if (substr.equals("")) return true;
    ...
}
</code></pre>

<p>函数里面尽早的return，可以让逻辑更加清晰。</p>

<h4>减少嵌套</h4>

<pre><code>if (user_result == SUCCESS) {
    if (permission_result != SUCCESS) {
        reply.WriteErrors("error reading permissions");
        reply.Done();
        return;
    }
    reply.WriteErrors("");
} else {
    reply.WriteErrors(user_result);
}
reply.Done();
</code></pre>

<p>这样一段代码，有一层的嵌套，但是看起来也会稍有迷惑，想想自己的代码，有没有类似的情况呢？可以换个思路去考虑这段代码，并且用尽早return的原则修改，看起来就舒服很多：</p>

<pre><code>if (user_result != SUCCESS) {
    reply.WriteErrors(user_result);
    reply.Done();
    return;
}
if (permission_result != SUCCESS) {
    reply.WriteErrors(permission_result);
    reply.Done();
    return;
}
reply.WriteErrors("");
reply.Done();
</code></pre>

<p>同样的，对于有嵌套的循环，可以采用同样的办法：</p>

<pre><code>for (int i = 0; i &lt; results.size(); i++) {
    if (results[i] != NULL) {
        non_null_count++;
        if (results[i]-&gt;name != "") {
            cout &lt;&lt; "Considering candidate..." &lt;&lt; endl;
            ...
        }
    }
}
</code></pre>

<p>换一种写法，尽早return，在循环中就用continue：</p>

<pre><code>for (int i = 0; i &lt; results.size(); i++) {
    if (results[i] == NULL) continue;
    non_null_count++;

    if (results[i]-&gt;name == "") continue;
    cout &lt;&lt; "Considering candidate..." &lt;&lt; endl;
    ... 
}
</code></pre>

<h3>拆分复杂表达式</h3>

<p>很显然的，越复杂的表达式，读起来越费劲，所以应该把那些复杂而庞大的表达式，拆分成一个个易于理解的小式子。</p>

<h4>用变量</h4>

<p>将复杂表达式拆分最简单的办法，就是增加一个变量：</p>

<pre><code>if line.split(':')[0].strip() == "root":

//用变量替换
username = line.split(':')[0].strip() 
if username == "root":
    ...
</code></pre>

<p>或者这个例子：</p>

<pre><code>if (request.user.id == document.owner_id) {
    // user can edit this document...
}
...
if (request.user.id != document.owner_id) {
// document is read-only...
}

//用变量替换
final boolean user_owns_document = (request.user.id == document.owner_id);
if (user_owns_document) {
    // user can edit this document...
}
...
if (!user_owns_document) {
    // document is read-only...
}
</code></pre>

<h4>逻辑替换</h4>

<ul>
<li>1) not (a or b or c)   <--> (not a) and (not b) and (not c)</li>
<li>2) not (a and b and c) <--> (not a) or (not b) or (not c)</li>
</ul>


<p>所以，就可以这样写：</p>

<pre><code>if (!(file_exists &amp;&amp; !is_protected)) Error("Sorry, could not read file.");

//替换
if (!file_exists || is_protected) Error("Sorry, could not read file.");
</code></pre>

<h4>不要滥用逻辑表达式</h4>

<pre><code>assert((!(bucket = FindBucket(key))) || !bucket-&gt;IsOccupied());
</code></pre>

<p>这样的代码完全可以用下面这个替换，虽然有两行，但是更易懂：</p>

<pre><code>bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket-&gt;IsOccupied());
</code></pre>

<p>像下面这样的表达式，最好也不要写，因为在有些语言中，x会被赋予第一个为<code>true</code>的变量的值：</p>

<pre><code>x = a || b || c
</code></pre>

<h4>拆解大表达式</h4>

<pre><code>var update_highlight = function (message_num) {
    if ($("#vote_value" + message_num).html() === "Up") {
        $("#thumbs_up" + message_num).addClass("highlighted");
        $("#thumbs_down" + message_num).removeClass("highlighted");
    } else if ($("#vote_value" + message_num).html() === "Down") {
        $("#thumbs_up" + message_num).removeClass("highlighted");
        $("#thumbs_down" + message_num).addClass("highlighted");
    } else {
        $("#thumbs_up" + message_num).removeClass("highighted");
        $("#thumbs_down" + message_num).removeClass("highlighted");
    }
};
</code></pre>

<p>这里面有很多重复的语句，我们可以用变量还替换简化：</p>

<pre><code>var update_highlight = function (message_num) {
    var thumbs_up = $("#thumbs_up" + message_num);
    var thumbs_down = $("#thumbs_down" + message_num);
    var vote_value = $("#vote_value" + message_num).html();
    var hi = "highlighted";

    if (vote_value === "Up") {
        thumbs_up.addClass(hi);
        thumbs_down.removeClass(hi);
    } else if (vote_value === "Down") {
        thumbs_up.removeClass(hi);
        thumbs_down.addClass(hi);
    } else {
        thumbs_up.removeClass(hi);
        thumbs_down.removeClass(hi);
    }
}
</code></pre>

<h3>变量与可读性</h3>

<h4>消除变量</h4>

<p>前一节，讲到利用变量来拆解大表达式，这一节来讨论如何消除多余的变量。</p>

<h4>没用的临时变量</h4>

<pre><code>now = datetime.datetime.now()
root_message.last_view_time = now
</code></pre>

<p>这里的<code>now</code>可以去掉，因为：</p>

<ul>
<li>并非用来拆分复杂的表达式</li>
<li>也没有增加可读性，因为`datetime.datetime.now()`本就清晰</li>
<li>只用了一次</li>
</ul>


<p>所以完全可以写作：</p>

<pre><code>root_message.last_view_time = datetime.datetime.now()
</code></pre>

<h4>消除条件控制变量</h4>

<pre><code>boolean done = false;
while (/* condition */ &amp;&amp; !done) {
    ...
    if (...) {
        done = true;
        continue; 
    }
}
</code></pre>

<p>这里的<code>done</code>可以用别的方式更好的完成：</p>

<pre><code>while (/* condition */) {
    ...
    if (...) {
        break;
    } 
}
</code></pre>

<p>这个例子非常容易修改，如果是比较复杂的嵌套，<code>break</code>可能并不够用，这时候就可以把代码封装到函数中。</p>

<h4>减少变量的作用域</h4>

<p>我们都听过要避免使用全局变量这样的忠告，是的，当变量的作用域越大，就越难追踪，所以要保持变量小的作用域。</p>

<pre><code>class LargeClass {
    string str_;
    void Method1() {
        str_ = ...;
        Method2();
    }
    void Method2() {
        // Uses str_
    }
    // Lots of other methods that don't use str_ 
    ... ;
}
</code></pre>

<p>这里的<code>str_</code>的作用域有些大，完全可以换一种方式：</p>

<pre><code>class LargeClass {
    void Method1() {
        string str = ...;
        Method2(str); 
    }
    void Method2(string str) {
        // Uses str
    }
    // Now other methods can't see str.
};
</code></pre>

<p>将<code>str</code>通过变量函数参数传递，减小了作用域，也更易读。同样的道理也可以用在定义类的时候，将大类拆分成一个个小类。</p>

<h4>不要使用嵌套的作用域</h4>

<pre><code># No use of example_value up to this point.
if request:
    for value in request.values:
    if value &gt; 0:
        example_value = value 
        break

for logger in debug.loggers:
    logger.log("Example:", example_value)
</code></pre>

<p>这个例子在运行时候会报<code>example_value is undefined</code>的错，修改起来不算难：</p>

<pre><code>example_value = None
if request:
    for value in request.values:
        if value &gt; 0: example_value = value 
        break

if example_value:
    for logger in debug.loggers:
    logger.log("Example:", example_value)
</code></pre>

<p>但是参考前面的<strong>消除中间变量</strong>准则，还有更好的办法：</p>

<pre><code>def LogExample(value):
    for logger in debug.loggers:
        logger.log("Example:", value)

    if request:
        for value in request.values:
            if value &gt; 0:
                LogExample(value)  # deal with 'value' immediately
                break
</code></pre>

<h4>用到了再声明</h4>

<p>在C语言中，要求将所有的变量事先声明，这样当用到变量较多时候，读者处理这些信息就会有难度，所以一开始没用到的变量，就暂缓声明：</p>

<pre><code>def ViewFilteredReplies(original_id):
    filtered_replies = []
    root_message = Messages.objects.get(original_id) 
    all_replies = Messages.objects.select(root_id=original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    for reply in all_replies:
        if reply.spam_votes &lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
</code></pre>

<p>读者一次处理变量太多，可以暂缓声明：</p>

<pre><code>def ViewFilteredReplies(original_id):
    root_message = Messages.objects.get(original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    all_replies = Messages.objects.select(root_id=original_id) 
    filtered_replies = []
    for reply in all_replies:
        if reply.spam_votes &lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
</code></pre>

<h4>变量最好只写一次</h4>

<p>前面讨论了过多的变量会让读者迷惑，同一个变量，不停的被赋值也会让读者头晕，如果变量变化的次数少一些，代码可读性就更强。</p>

<h4>一个例子</h4>

<p>假设有一个页面，如下，需要给第一个空的<code>input</code>赋值：</p>

<pre><code>&lt;input type="text" id="input1" value="Dustin"&gt;
&lt;input type="text" id="input2" value="Trevor"&gt;
&lt;input type="text" id="input3" value=""&gt;
&lt;input type="text" id="input4" value="Melissa"&gt;
...
var setFirstEmptyInput = function (new_value) {
    var found = false;
    var i = 1;
    var elem = document.getElementById('input' + i);
    while (elem !== null) {
        if (elem.value === '') {
            found = true;
            break; 
        }
        i++;
        elem = document.getElementById('input' + i);
    }
    if (found) elem.value = new_value;
    return elem;
};
</code></pre>

<p>这段代码能工作，有三个变量，我们逐一去看如何优化，<code>found</code>作为中间变量，完全可以消除：</p>

<pre><code>var setFirstEmptyInput = function (new_value) {
    var i = 1;
    var elem = document.getElementById('input' + i);
    while (elem !== null) {
        if (elem.value === '') {
            elem.value = new_value;
            return elem;
        }
        i++;
        elem = document.getElementById('input' + i);
    }
    return null;
};
</code></pre>

<p>再来看<code>elem</code>变量，只用来做循环，调用了很多次，所以很难跟踪他的值，<code>i</code>也可以用<code>for</code>来修改：</p>

<pre><code>var setFirstEmptyInput = function (new_value) {
    for (var i = 1; true; i++) {
        var elem = document.getElementById('input' + i);
        if (elem === null)
            return null;  // Search Failed. No empty input found.
        if (elem.value === '') {
            elem.value = new_value;
            return elem;
        }
    }
};
</code></pre>

<h2>重新组织你的代码</h2>

<h3>分离不相关的子问题</h3>

<p>工程师就是将大问题分解为一个个小问题，然后逐个解决，这样也易于保证程序的健壮性、可读性。如何分解子问题，下面给出一些准则：</p>

<ul>
<li>看看这个方法或代码，问问你自己“这段代码的最终目标是什么？”</li>
<li>对于每一行代码，要问“它与目标直接相关，或者是不相关的子问题？”</li>
<li>如果有足够多行的代码是处理与目标不直接相关的问题，那么抽离成子函数</li>
</ul>


<p>来看一个例子：</p>

<pre><code>ajax_post({
    url: 'http://example.com/submit',
    data: data,
    on_success: function (response_data) {
        var str = "{\n";
        for (var key in response_data) {
            str += "  " + key + " = " + response_data[key] + "\n";
        }
        alert(str + "}");
        // Continue handling 'response_data' ...
    }
});
</code></pre>

<p>这段代码的目标是发送一个<code>ajax</code>请求，所以其中字符串处理的部分就可以抽离出来：</p>

<pre><code>var format_pretty = function (obj) {
    var str = "{\n";
    for (var key in obj) {
        str += "  " + key + " = " + obj[key] + "\n";
    }
    return str + "}";
};
</code></pre>

<h4>意外收获</h4>

<p>有很多理由将<code>format_pretty</code>抽离出来，这些独立的函数可以很容易的添加feature，增强可靠性，处理边界情况，等等。所以这里，可以将<code>format_pretty</code>增强，就会得到一个更强大的函数：</p>

<pre><code>var format_pretty = function (obj, indent) {
    // Handle null, undefined, strings, and non-objects.
    if (obj === null) return "null";
    if (obj === undefined) return "undefined";
    if (typeof obj === "string") return '"' + obj + '"';
    if (typeof obj !== "object") return String(obj);
    if (indent === undefined) indent = "";

    // Handle (non-null) objects.

    var str = "{\n";
    for (var key in obj) {
        str += indent + "  " + key + " = ";
        str += format_pretty(obj[key], indent + " ") + "\n"; }
    return str + indent + "}";
};
</code></pre>

<p>这个函数输出：</p>

<pre><code>{
    key1 = 1
    key2 = true
    key3 = undefined
    key4 = null
    key5 = {
        key5a = {
            key5a1 = "hello world"
        }
    }
}
</code></pre>

<p>多做这样的事情，就是积累代码的过程，这样的代码可以复用，也可以形成自己的代码库，或者分享给别人。</p>

<h4>业务相关的函数</h4>

<p>那些与目标不相关函数，抽离出来可以复用，与业务相关的也可以抽出来，保持代码的易读性，例如：</p>

<pre><code>business = Business()
business.name = request.POST["name"]

url_path_name = business.name.lower()
url_path_name = re.sub(r"['\.]", "", url_path_name) 
url_path_name = re.sub(r"[^a-z0-9]+", "-", url_path_name) 
url_path_name = url_path_name.strip("-")
business.url = "/biz/" + url_path_name

business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
</code></pre>

<p>抽离出来，就好看很多：</p>

<pre><code>CHARS_TO_REMOVE = re.compile(r"['\.']+")
CHARS_TO_DASH = re.compile(r"[^a-z0-9]+")

def make_url_friendly(text):
    text = text.lower()
    text = CHARS_TO_REMOVE.sub('', text) 
    text = CHARS_TO_DASH.sub('-', text) 
    return text.strip("-")

business = Business()
business.name = request.POST["name"]
business.url = "/biz/" + make_url_friendly(business.name) 
business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
</code></pre>

<h4>简化现有接口</h4>

<p>我们来看一个读写cookie的函数：</p>

<pre><code>var max_results;
var cookies = document.cookie.split(';');
for (var i = 0; i &lt; cookies.length; i++) {
    var c = cookies[i];
    c = c.replace(/^[ ]+/, '');  // remove leading spaces
    if (c.indexOf("max_results=") === 0)
        max_results = Number(c.substring(12, c.length));
}
</code></pre>

<p>这段代码实在太丑了，理想的接口应该是这样的：</p>

<pre><code>set_cookie(name, value, days_to_expire);
delete_cookie(name);
</code></pre>

<p>对于并不理想的接口，你永远可以用自己的函数做封装，让接口更好用。</p>

<h4>按自己需要写接口</h4>

<pre><code>ser_info = { "username": "...", "password": "..." }
user_str = json.dumps(user_info)
cipher = Cipher("aes_128_cbc", key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)
encrypted_bytes = cipher.update(user_str)
encrypted_bytes += cipher.final() # flush out the current 128 bit block
url = "http://example.com/?user_info=" + base64.urlsafe_b64encode(encrypted_bytes)
...
</code></pre>

<p>虽然终极目的是拼接用户信息的字符，但是代码大部分做的事情是解析python的object，所以：</p>

<pre><code>def url_safe_encrypt(obj):
    obj_str = json.dumps(obj)
    cipher = Cipher("aes_128_cbc", key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str)
    encrypted_bytes += cipher.final() # flush out the current 128 bit block
    return base64.urlsafe_b64encode(encrypted_bytes)
</code></pre>

<p>这样在其他地方也可以调用：</p>

<pre><code>user_info = { "username": "...", "password": "..." }
url = "http://example.com/?user_info=" + url_safe_encrypt(user_info)
</code></pre>

<p>分离子函数是好习惯，但是也要适度，过度的分离成多个小函数，也会让查找变得困难。</p>

<h3>单任务</h3>

<p>代码应该是一次只完成一个任务</p>

<pre><code>var place = location_info["LocalityName"];  // e.g. "Santa Monica"
if (!place) {
    place = location_info["SubAdministrativeAreaName"];  // e.g. "Los Angeles"
}
if (!place) {
    place = location_info["AdministrativeAreaName"];  // e.g. "California"
}
if (!place) {
    place = "Middle-of-Nowhere";
}
if (location_info["CountryName"]) {
    place += ", " + location_info["CountryName"];  // e.g. "USA"
} else {
    place += ", Planet Earth";
}

return place;
</code></pre>

<p>这是一个用来拼地名的函数，有很多的条件判断，读起来非常吃力，有没有办法拆解任务呢？</p>

<pre><code>var town    = location_info["LocalityName"];               // e.g. "Santa Monica"
var city    = location_info["SubAdministrativeAreaName"];  // e.g. "Los Angeles"
var state   = location_info["AdministrativeAreaName"];     // e.g. "CA"
var country = location_info["CountryName"];                // e.g. "USA"
</code></pre>

<p>先拆解第一个任务，将各变量分别保存，这样在后面使用中不需要去记忆那些繁长的key值了，第二个任务，解决地址拼接的后半部分：</p>

<pre><code>// Start with the default, and keep overwriting with the most specific value. var second_half = "Planet Earth";
if (country) {
    second_half = country; 
}
if (state &amp;&amp; country === "USA") {
    second_half = state; 
}
</code></pre>

<p>再来解决前半部分：</p>

<pre><code>var first_half = "Middle-of-Nowhere";
if (state &amp;&amp; country !== "USA") {
    first_half = state; 
}
if (city) {
    first_half = city;
}
if (town) {
    first_half = town; 
}
</code></pre>

<p>大功告成：</p>

<pre><code>return first_half + ", " + second_half;
</code></pre>

<p>如果注意到有<code>USA</code>这个变量的判断的话，也可以这样写：</p>

<pre><code>var first_half, second_half;
if (country === "USA") {
    first_half = town || city || "Middle-of-Nowhere";
    second_half = state || "USA";
} else {
    first_half = town || city || state || "Middle-of-Nowhere";
    second_half = country || "Planet Earth";
}
return first_half + ", " + second_half;
</code></pre>

<h3>把想法转换成代码</h3>

<p>要把一个复杂的东西解释给别人，一些细节很容易就让人产生迷惑，所以想象把你的代码用平实的语言解释给别人听，别人是否能懂，有一些准则可以帮助你让代码更清晰：</p>

<ul>
<li>用最平实的语言描述代码的目的，就像给读者讲述一样</li>
<li>注意描述中关键的字词</li>
<li>让你的代码符合你的描述</li>
</ul>


<p>下面这段代码用来校验用户的权限：</p>

<pre><code>$is_admin = is_admin_request();
if ($document) {
    if (!$is_admin &amp;&amp; ($document['username'] != $_SESSION['username'])) {
        return not_authorized();
    }
} else {
    if (!$is_admin) {
        return not_authorized();
    } 
}
// continue rendering the page ...
</code></pre>

<p>这一段代码不长，里面的逻辑嵌套倒是复杂，参考前面章节所述，嵌套太多非常影响阅读理解，将这个逻辑用语言描述就是：</p>

<pre><code>有两种情况有权限：
1、你是管理员(admin)
2、你拥有这个文档
否则就没有权限
</code></pre>

<p>根据描述来写代码：</p>

<pre><code>if (is_admin_request()) {
    // authorized
} elseif ($document &amp;&amp; ($document['username'] == $_SESSION['username'])) {
    // authorized
} else {
    return not_authorized();
}
// continue rendering the page ...
</code></pre>

<h3>写更少的代码</h3>

<p>最易懂的代码就是没有代码！</p>

<ul>
<li>去掉那些没意义的feature，也不要过度设计</li>
<li>重新考虑需求，解决最简单的问题，也能完成整体的目标</li>
<li>熟悉你常用的库，周期性研究他的API</li>
</ul>


<h2>最后</h2>

<p>还有一些与测试相关的章节，留给你自己去研读吧，再次推荐此书：</p>

<ul>
<li>英文版：<a href="http://book.douban.com/subject/5442971/" title="The Art Of Readable Code">《The Art of Readable Code》</a></li>
<li>中文版：<a href="http://book.douban.com/subject/10797189/" title="编写可读代码的艺术">编写可读代码的艺术</a></li>
</ul>



        <div id="disqus_container">
            <div style="margin-bottom:20px" class="right">
                <script type="text/javascript" charset="utf-8">
                (function(){
                  var _w = 86 , _h = 16;
                  var param = {
                    url:location.href,
                    type:'6',
                    count:'', /**是否显示分享数，1显示(可选)*/
                    appkey:'', /**您申请的应用appkey,显示分享来源(可选)*/
                    title:'', /**分享的文字内容(可选，默认为所在页面的title)*/
                    pic:'', /**分享图片的路径(可选)*/
                    ralateUid:'1855270953', /**关联用户的UID，分享微博会@该用户(可选)*/
                    language:'zh_cn', /**设置语言，zh_cn|zh_tw(可选)*/
                    rnd:new Date().valueOf()
                  }
                  var temp = [];
                  for( var p in param ){
                    temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )
                  }
                  document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="'+ _w+'" height="'+_h+'"></iframe>')
                })()
                </script>
            </div>
            <a href="#" class="comment" onclick="return false;">点击查看评论</a>
            <div id="disqus_thread"></div>
        </div>
    </div>

    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/git-update">github网站的目录结构</a></li>
        
            <li><a href="/css3-animation">CSS3动画详解</a></li>
        
            <li><a href="/grunt-in-action">Grunt.js 在前端项目中的实战</a></li>
        
            <li><a href="/readable-code">编写可读代码的艺术</a></li>
        
            <li><a href="/religion-basic">宗教基本知识</a></li>
        
            <li><a href="/git-vim-tutorial">Git时代的VIM不完全使用教程</a></li>
        
            <li><a href="/backbone-js-chrome-extension">使用Backbone.js开发Chrome便签插件</a></li>
        
            <li><a href="/buy-guitar">如何选择与购买吉他</a></li>
        
            <li><a href="/github-pages">使用Github Pages建独立博客</a></li>
        
            <li><a href="/why-blog">我为什么写博客？</a></li>
        
        </ul>

        <h2>Opinion</h2>
        <ul class="artical-list">
        
            <li><a href="/douban-fm">豆瓣FM(iOS 3.0)使用体会</a></li>
        
            <li><a href="/jobs-interview">史蒂夫·乔布斯：遗失的访谈</a></li>
        
            <li><a href="/40-ama-55-grammy">40届全美音乐奖和55届格莱美颁奖演出观感</a></li>
        
            <li><a href="/build-facebook">只有好的棋手才会走运</a></li>
        
            <li><a href="/bad-list-design">令人焦虑的列表设计</a></li>
        
            <li><a href="/about-simplify">胡言乱语说简单</a></li>
        
            <li><a href="/auto-edit-bar">随内容滚动隐藏的工具栏</a></li>
        
            <li><a href="/side-slide">如果侧滑成为APP标配</a></li>
        
            <li><a href="/needs-video">谈谈刚需和360影视</a></li>
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
            <li><a href="/tabby">Tabby</a></li>
        
            <li><a href="/notty-notes">Notty Notes</a></li>
        
            <li><a href="/overapi-cheatsheet">OverAPI</a></li>
        
            <li><a href="/raining-in-chrome">听雨</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <!--*********************************************************-->
    <!--****** 宝贝儿，看见这个时候，删掉下面的统计代码哦~ ******-->
    <!--************* 再推荐下我的第一篇博客哦~~ ****************-->
    <!--*********************************************************-->

    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
